Design and Function

Character Design and Function
-----------------------------

+------+-----------------------------------------------------------------------+
| Stat | Description                                                           |
+======+=======================================================================+
| AG   | Agility. Increases chance to disarm attacks, flee, and dodge. Also    |
|      | increases a character's ability to disarm traps without misfire.      |
+------+-----------------------------------------------------------------------+
| IQ   | Intelligence. Increases the effectiveness and success rate of         |
|      | mage/psionic spells.                                                  |
+------+-----------------------------------------------------------------------+
| LK   | Luck increases your resistance to status effects and chance for rare  |
|      | items to drop from enemies. Also increases ability to disarm traps    |
|      | without misfire.                                                      |
+------+-----------------------------------------------------------------------+
| PI   | Piety increases the effectiveness and success rate for all priest     |
|      | spells                                                                |
+------+-----------------------------------------------------------------------+
| ST   | Strength increases physical damage done and the hit rate for all      |
|      | physical attacks.                                                     |
+------+-----------------------------------------------------------------------+
| VT   | Vitality increases the amount of hit points a character receives when |
|      | they level up.                                                        |
+------+-----------------------------------------------------------------------+
| AC   | Armor Class.  The lower the number (into negative numbers), the       |
|      | harder the target is to hit.                                          |
+------+-----------------------------------------------------------------------+

Alignment
---------
All characters have an "alignment", which indicates their world view as follows:
* Good - Merciful upon others who mean them no harm.
* Neutral - Neither especially lenient or merciless.
* Evil - Will destroy all who stand before them, even friendly monsters.

Some classes have alignment requirements. For instance, Priest characters must
be Good or Evil, but not Neutral. Thieves may be Neutral or Evil, but not Good.
Ninjas may only be Evil, and Lords may only be Good.

Some equipment is intended for characters of specific alignments. If a character
attempts to equip an item and does not meet the alignment requirements for that
item, he may be denied the right to equip the item or he may be cursed upon
equipping the item.

Characters of opposing alignments will not join the same party under normal
conditions. If a party has only Good and Neutral characters in it and the player
attempts to add an Evil character to an avilable slot while at the Tavern in 
town (where parties are assembled), the Evil character will refuse to join.  The 
opposite is also true. However, characters can be dropped off in the dungeon and 
a party with opposing alignment can then search for them while in the dungeon 
and add them to their ranks.  The opposing character will remain in the party 
until removed in town.

Maps
----

1. Three arrays of objects - map_initial, and map_save (explored area), and
    map_in_play (current in memory copy). Map_initial and map_save are both 
    reflected in the files mapname.map and mapname.save

2. Map_in_play is generated:
	a. load the user-modified "map_save" array of "room" objects from
    mapname.save
	b. load the non-changing "map_initial" array of "room" objects from
    mapname.map
	c. For each object in "map_save", if "has_been_occupied" value is true
    copy the tuple to the "map_in_play" final array, else read the location
    value and load tuple with identical location value from "map_initial" into
    "map_in_play".

3. Map_in_play is updated:
	a. mark tuple in map_in_play at player location value "is_occupied" value
    true
	b. if event_on_occupy is not 0, play_event(event_on_occupy)
	c. mark tuple in map_in_play at player location value "has_been_occupied"
    to true

Values in each "tile" tuple:
	Location(x,y)
	Can_be_occupied(t/f)
    Is_occupied(t/f)
	Has_been_occupied(t/f)
	Event_on_occupy(event_number)
	What_is_(north/south/east/west)
		exit, wall, door, secret door, grate (triggered), event

Map generation:
    Maps for each dungeon are procedurally generated at the start of a new game.
    This is not frequent, as the same save game is used regardless of the party
    members chosen.  Even if all characters in play are "gone" (dead, then ash,
    then gone), the dungeon will not change when the player generates a new
    party and goes back into the dungeon. The dungeons are re-generated on
    meeting the following conditions:
    1) The game is "beaten", with the characters defeating the final boss and
    returning to town victorious. When this happens, the players are notified
    that "true evil never dies", and the dungeons are re-generated, along with
    all bosses, treasure and traps.
    2) The player chooses to regenerate the dungeons.  This will be an option
    within town.  Upon regeneration, all dungeons will lose their "state" and
    all saved progress and auto-maps are reset.  Any characters which are still
    in the dungeon will be returned to town and will be staying at the inn. The
    player may regenerate dungeon as many times as desired, but the prior 
    dungeon is permanently removed (no retrieval).
    3) the player chooses a "new game" from the main screen.  This will
    completely regenerate the dungeons and will permanently reset the game
    state, removing all player-generated characters, loot and progress. The
    player will be notified sufficiently of this.

    Generated maps are not completely random, but are generated procedurally.
    This is to provide the player with more interesting manual mapping (on graph
    paper), and to provide a bit more predictability to the maps. A possible
    method would be to first create a "section" from pre-defined rooms and
    hallway segments, then mirror and rotate that section to create a "quadrant"
    which is then mirrored and rotated to create the rest of the map.  This
    should provide a "geometric pattern"-style of map.


Items
-----

Item drops:
    a. Item drops will be level-based, rather than monster-based.  Thus, each
    level of each tower will have a static drop list and all mobs on that
    level have the potential to drop items from that list.
    b. ALL items will be "unidentified" upon pickup. Items can be identified
    either by a character with the Bishop class or by the merchant in town.
Item properties:
    Description - Long description (if you investigate the item)
    Name - Long name (if you investigate the item)
    Short_name - Displayed in the character's inventory listing
Notes:
    Once acquired, items occupy an inventory slot until they are used or
    destroyed.  Items can be deposited in town at the appropriate shop (see
    "bank" below).
    When "dropped", an item is destroyed and gone forever.
    All items can be used at any time, but only have an effect under specific
    conditions.
    Items such as potions and scrolls are single-use "portable spells" that can
    be used by any character class or race. When used, they are marked as 
    "broken" and are unusable. In classic Wizardry, there is no way to repair 
    these items - they just take up space until they are dropped (destroyed).
    Should it be possible to "repair" "broken" items if certain conditions are 
    met?

Equipment
---------
Weapons, Armor, Accessories are all "equipment" but are still instances of the 
"Item" class.  Equipment will have a different initialization method (__init__) 
which requires the appropriate input (listed below).

Equipment properties:
    Is_equippable(t/f)
    Is_equipped(t/f)
    Min_dmg(int)
    Max_dmg(int)
    Hit_multiplier(float)
    Equip_effect([]) - list of index numbers/keys. There will be a dictionary of
    "spell" effects, and this list contains a key for each effect the item needs
    to have when equipped.
    Use_effect(int) - key related to the spell dictionary, for what effect the
    item has when used as an item


Saving the game
---------------
Saving the game should mitigate "save scumming" (the use of frequent saves
to circumvent challenges or cheat random rolls), but should be useful to
the user.
The game should automatically save the progress of the game for the player
at regular intervals:
* After a battle concludes (win, lose or retreat)
* Upon returning to/leaving town
* Game is closed/quit
The player can save the game manually in a SEPARATE slot from the auto-save 
feature. There is only ONE slot for manual saves. When the player saves the
game again, the existing save is overwritten. The player will be allowed to
save at the following times:
* In camp
* In town
* Between battles (not during) so long as an event is not taking place

This save behavior is different in "hardcore" mode. See "hardcore mode" section.

Hardcore Mode
-------------

In hardcore mode, a number of changes make the game more challenging.

Saving:
* The player-controlled manual save game is disabled
* Automatic saving does NOT occur after battles
* The game is saved when the party returns to town
* The game is saved when the player quits the game

Mapping:
* The auto-generated map is no longer available at will - something will limit
  its use (uses a spell slot to view map or similar). The idea is to
  encourage/force the player to maintain hand-drawn maps of the dungeon. Perhaps
  the best idea is an item carried in the inventory which has a limited number
  of "charges" which are replenished upon return to town. This would work well
  in normal mode (remove the charge restriction) and hardcore mode.
  Alternately, there could be a special skill given to a specific class (such as
  mages) which allows map viewing, and charges could be applied to that skill.

Death
-----
"Death" is a vital game mechanic/aesthetic.  It should be common enough that the
player fears it but not so frequent that the game seems unfair or unplayable.
Death is a threat to all player characters - no-one is immune.
When a player character is reduced to 0 or fewer HP, that character "dies". The
character will remain in the current party until the party returns to town.
Upon the party's return to town, all "dead" or "ashes" characters will be
transferred to the Temple automatically.
The player can attempt to revive a character a limited number of times. If the
first revival fails, the character turns to "ashes".  If another revival is
attempted while the character is "ashes" and this also fails, the character is
lost forever ("gone") and they will be listed in the "hall of adventurers".
Equipment from "gone" characters will be stored at the Temple until retrieved by
the player.
(see temple in town.txt)

Monsters
--------
See "monsters.txt" 


Spells/Spellcasting
-------------------
Spells in Wizardry have classically had a unique "Wizardry" naming scheme.
Instead of "Heal" the spell is named "Dios".  Instead of "Heal more" the
spell is named "Dial".  Intstead of "Great heal" the spell is named "Dialma".
While this does give the spells a consistent naming scheme, selecting spells
is hampered by being reqired to memorize odd names or reference a list. While
this form of play should be an option, the player will also be provided with
the option to play with "Anglicised" names instead to make spell
identification easier and faster.

Slots vs. Magic Points
----------------------
Wizardry has typically employed a "spell slot" mechanic for casters. For
instance, 5/4/3/2/1/0/0/0/0 would indicate that the character could cast 5
level 1 spells, 4 level 2 spells, 3 level 3 spells, and so on. When a character
casts a spell of a given level, the number in that "slot" is decremented by
one. This is opposed to the "magic point" mechanic, where each spell has a given
cost in magic points, and the character has a "pool" of MP to draw from. It
seems that the "slot" mechanic is employed for at least two reasons: to keep
casters from being too powerful/flexible (can't cast 3 lvl 4 spells instead of
7 lvl 1 spells, etc.), and to force players to carefully manage their spells
(do I cast a damage spell in battle, or save the slot for the auto-map
feature/wall detection?). For now, I plan to keep with the "spell slot"
mechanic.

TODO:
How do event driven encounters work?
